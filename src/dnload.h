#ifndef DNLOAD_H
#define DNLOAD_H

/** \file
 * \brief Dynamic loader header stub.
 *
 * This file was automatically generated by 'dnload.py'.
 */

#if defined(WIN32)
/** \cond */
#define _USE_MATH_DEFINES
#define NOMINMAX
/** \endcond */
#else
/** \cond */
#define GL_GLEXT_PROTOTYPES
/** \endcond */
#endif

#if defined(__cplusplus)
#include <cmath>
#include <cstdio>
#include <cstdlib>
#else
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#endif

#include "ft2build.h"
#include FT_FREETYPE_H

#if defined(DNLOAD_VIDEOCORE)
#include "bcm_host.h"
#include "EGL/egl.h"
#endif

#if defined(USE_LD)
#if defined(WIN32)
#include "windows.h"
#include "GL/glew.h"
#include "GL/glu.h"
#elif defined(__APPLE__)
#include "GL/glew.h"
#include <OpenGL/glu.h>
#else
#if defined(DNLOAD_GLESV2)
#include "GLES2/gl2.h"
#include "GLES2/gl2ext.h"
#else
#include "GL/glew.h"
#include "GL/glu.h"
#endif
#endif
#else
#if defined(__APPLE__)
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>
#include <OpenGL/glu.h>
#else
#if defined(DNLOAD_GLESV2)
#include "GLES2/gl2.h"
#include "GLES2/gl2ext.h"
#else
#include "GL/gl.h"
#include "GL/glext.h"
#include "GL/glu.h"
#endif
#endif
#endif

#include "png.h"

#if defined(USE_LD)
#include "bsd_rand.h"
#else
#define DNLOAD_RAND_IMPLEMENTATION_BSD 1
#define DNLOAD_RAND_IMPLEMENTATION_GNU 0
#if defined(__FreeBSD__)
#if !DNLOAD_RAND_IMPLEMENTATION_BSD
#include "bsd_rand.h"
#include "bsd_rand.c"
#else
#define bsd_rand rand
#define bsd_srand srand
#endif
#elif defined(__linux__)
#if !DNLOAD_RAND_IMPLEMENTATION_GNU
#include "bsd_rand.h"
#include "bsd_rand.c"
#else
#define gnu_rand rand
#define gnu_srand srand
#endif
#endif
#endif

#include "SDL.h"

#if defined(SDL_INIT_EVERYTHING) && defined(__APPLE__) 
#define DNLOAD_MAIN SDL_main
#else
#define DNLOAD_MAIN main
#endif

/** Macro stringification helper (adds indirection). */
#define DNLOAD_MACRO_STR_HELPER(op) #op
/** Macro stringification. */
#define DNLOAD_MACRO_STR(op) DNLOAD_MACRO_STR_HELPER(op)

#if defined(DNLOAD_GLESV2)
/** Apientry definition (OpenGL ES 2.0). */
#define DNLOAD_APIENTRY GL_APIENTRY
#else
/** Apientry definition (OpenGL). */
#define DNLOAD_APIENTRY GLAPIENTRY
#endif

#if (defined(_LP64) && _LP64) || (defined(__LP64__) && __LP64__)
/** Size of pointer in bytes (64-bit). */
#define DNLOAD_POINTER_SIZE 8
#else
/** Size of pointer in bytes (32-bit). */
#define DNLOAD_POINTER_SIZE 4
#endif

#if !defined(USE_LD)
/** Error string for when assembler exit procedure is not available. */
#define DNLOAD_ASM_EXIT_ERROR "no assembler exit procedure defined for current operating system or architecture"
/** Perform exit syscall in assembler. */
static void asm_exit(void)
{
#if !defined(DNLOAD_NO_DEBUGGER_TRAP) && (defined(__x86_64__) || defined(__i386__))
  asm("int $0x3" : /* no output */ : /* no input */ : /* no clobber */);
#elif defined(__x86_64__)
#if defined(__FreeBSD__)
  asm_exit() asm("syscall" : /* no output */ : "a"(1) : /* no clobber */);
#elif defined(__linux__)
  asm_exit() asm("syscall" : /* no output */ : "a"(60) : /* no clobber */);
#else
#pragma message DNLOAD_MACRO_STR(DNLOAD_ASM_EXIT_ERROR)
#error
#endif
#elif defined(__i386__)
#if defined(__FreeBSD__) || defined(__linux__)
  asm("int $0x80" : /* no output */ : "a"(1) : /* no clobber */);
#else
#pragma message DNLOAD_MACRO_STR(DNLOAD_ASM_EXIT_ERROR)
#error
#endif
#elif defined(__arm__)
#if defined(__linux__)
  register int r7 asm("r7") = 1;
  asm("swi #0" : /* no output */ : "r"(r7) : /* no clobber */);
#else
#pragma message DNLOAD_MACRO_STR(DNLOAD_ASM_EXIT_ERROR)
#error
#endif
#else
#pragma message DNLOAD_MACRO_STR(DNLOAD_ASM_EXIT_ERROR)
#error
#endif
}
#endif

#if defined(USE_LD)
/** \cond */
#define dnload_glGenerateMipmap glGenerateMipmap
#define dnload_SDL_CondSignal SDL_CondSignal
#define dnload_png_create_read_struct png_create_read_struct
#define dnload_SDL_CondWait SDL_CondWait
#define dnload_fmodf fmodf
#define dnload_glFramebufferTexture2D glFramebufferTexture2D
#define dnload_sinf sinf
#define dnload_glUseProgramStages glUseProgramStages
#define dnload_png_set_read_fn png_set_read_fn
#define dnload_glBindProgramPipeline glBindProgramPipeline
#define dnload_SDL_GL_SwapWindow SDL_GL_SwapWindow
#define dnload_SDL_PauseAudio SDL_PauseAudio
#define dnload_SDL_Delay SDL_Delay
#define dnload_FT_Set_Pixel_Sizes FT_Set_Pixel_Sizes
#define dnload_FT_New_Face FT_New_Face
#define dnload_cosf cosf
#define dnload_SDL_UnlockMutex SDL_UnlockMutex
#define dnload_sqrtf sqrtf
#define dnload_png_get_IHDR png_get_IHDR
#define dnload_SDL_OpenAudio SDL_OpenAudio
#define dnload_png_set_tRNS_to_alpha png_set_tRNS_to_alpha
#define dnload_SDL_CreateWindow SDL_CreateWindow
#define dnload_SDL_WaitThread SDL_WaitThread
#define dnload_SDL_PollEvent SDL_PollEvent
#define dnload_srand bsd_srand
#define dnload_SDL_DestroyMutex SDL_DestroyMutex
#define dnload_SDL_Init SDL_Init
#define dnload_SDL_LockMutex SDL_LockMutex
#define dnload_glGenProgramPipelines glGenProgramPipelines
#define dnload_FT_Init_FreeType FT_Init_FreeType
#define dnload_SDL_Quit SDL_Quit
#define dnload_SDL_CreateThread SDL_CreateThread
#define dnload_FT_Render_Glyph FT_Render_Glyph
#define dnload_SDL_CreateCond SDL_CreateCond
#define dnload_powf powf
#define dnload_glBindTexture glBindTexture
#define dnload_glGenTextures glGenTextures
#define dnload_SDL_DestroyCond SDL_DestroyCond
#define dnload_tanhf tanhf
#define dnload_glBindFramebuffer glBindFramebuffer
#define dnload_glTexImage2D glTexImage2D
#define dnload_glTexImage3D glTexImage3D
#define dnload_glCreateShaderProgramv glCreateShaderProgramv
#define dnload_png_read_row png_read_row
#define dnload_FT_Get_Char_Index FT_Get_Char_Index
#define dnload_glGenFramebuffers glGenFramebuffers
#define dnload_realloc realloc
#define dnload_glDisable glDisable
#define dnload_glBlendFuncSeparate glBlendFuncSeparate
#define dnload_SDL_ShowCursor SDL_ShowCursor
#define dnload_free free
#define dnload_png_set_expand png_set_expand
#define dnload_glProgramUniform2fv glProgramUniform2fv
#define dnload_glProgramUniform3fv glProgramUniform3fv
#define dnload_glProgramUniform4fv glProgramUniform4fv
#define dnload_SDL_CreateMutex SDL_CreateMutex
#define dnload_glProgramUniformMatrix3fv glProgramUniformMatrix3fv
#define dnload_SDL_GetTicks SDL_GetTicks
#define dnload_glRects glRects
#define dnload_asinf asinf
#define dnload_png_create_info_struct png_create_info_struct
#define dnload_glActiveTexture glActiveTexture
#define dnload_FT_Load_Glyph FT_Load_Glyph
#define dnload_SDL_GL_CreateContext SDL_GL_CreateContext
#define dnload_png_read_info png_read_info
#define dnload_glTexParameterf glTexParameterf
#define dnload_glTexParameteri glTexParameteri
#define dnload_glProgramUniform1f glProgramUniform1f
#define dnload_glProgramUniform1i glProgramUniform1i
#define dnload_glReadPixels glReadPixels
#define dnload_png_get_valid png_get_valid
#define dnload_rand bsd_rand
#define dnload_glViewport glViewport
#define dnload_glEnable glEnable
/** \endcond */
#else
/** \cond */
#define dnload_glGenerateMipmap g_symbol_table.glGenerateMipmap
#define dnload_SDL_CondSignal g_symbol_table.SDL_CondSignal
#define dnload_png_create_read_struct g_symbol_table.png_create_read_struct
#define dnload_SDL_CondWait g_symbol_table.SDL_CondWait
#define dnload_fmodf g_symbol_table.fmodf
#define dnload_glFramebufferTexture2D g_symbol_table.glFramebufferTexture2D
#define dnload_sinf g_symbol_table.sinf
#define dnload_glUseProgramStages g_symbol_table.glUseProgramStages
#define dnload_png_set_read_fn g_symbol_table.png_set_read_fn
#define dnload_glBindProgramPipeline g_symbol_table.glBindProgramPipeline
#define dnload_SDL_GL_SwapWindow g_symbol_table.SDL_GL_SwapWindow
#define dnload_SDL_PauseAudio g_symbol_table.SDL_PauseAudio
#define dnload_SDL_Delay g_symbol_table.SDL_Delay
#define dnload_FT_Set_Pixel_Sizes g_symbol_table.FT_Set_Pixel_Sizes
#define dnload_FT_New_Face g_symbol_table.FT_New_Face
#define dnload_cosf g_symbol_table.cosf
#define dnload_SDL_UnlockMutex g_symbol_table.SDL_UnlockMutex
#define dnload_sqrtf sqrtf
#define dnload_png_get_IHDR g_symbol_table.png_get_IHDR
#define dnload_SDL_OpenAudio g_symbol_table.SDL_OpenAudio
#define dnload_png_set_tRNS_to_alpha g_symbol_table.png_set_tRNS_to_alpha
#define dnload_SDL_CreateWindow g_symbol_table.SDL_CreateWindow
#define dnload_SDL_WaitThread g_symbol_table.SDL_WaitThread
#define dnload_SDL_PollEvent g_symbol_table.SDL_PollEvent
#define dnload_srand g_symbol_table.srand
#define dnload_SDL_DestroyMutex g_symbol_table.SDL_DestroyMutex
#define dnload_SDL_Init g_symbol_table.SDL_Init
#define dnload_SDL_LockMutex g_symbol_table.SDL_LockMutex
#define dnload_glGenProgramPipelines g_symbol_table.glGenProgramPipelines
#define dnload_FT_Init_FreeType g_symbol_table.FT_Init_FreeType
#define dnload_SDL_Quit g_symbol_table.SDL_Quit
#define dnload_SDL_CreateThread g_symbol_table.SDL_CreateThread
#define dnload_FT_Render_Glyph g_symbol_table.FT_Render_Glyph
#define dnload_SDL_CreateCond g_symbol_table.SDL_CreateCond
#define dnload_powf g_symbol_table.powf
#define dnload_glBindTexture g_symbol_table.glBindTexture
#define dnload_glGenTextures g_symbol_table.glGenTextures
#define dnload_SDL_DestroyCond g_symbol_table.SDL_DestroyCond
#define dnload_tanhf g_symbol_table.tanhf
#define dnload_glBindFramebuffer g_symbol_table.glBindFramebuffer
#define dnload_glTexImage2D g_symbol_table.glTexImage2D
#define dnload_glTexImage3D g_symbol_table.glTexImage3D
#define dnload_glCreateShaderProgramv g_symbol_table.glCreateShaderProgramv
#define dnload_png_read_row g_symbol_table.png_read_row
#define dnload_FT_Get_Char_Index g_symbol_table.FT_Get_Char_Index
#define dnload_glGenFramebuffers g_symbol_table.glGenFramebuffers
#define dnload_realloc g_symbol_table.realloc
#define dnload_glDisable g_symbol_table.glDisable
#define dnload_glBlendFuncSeparate g_symbol_table.glBlendFuncSeparate
#define dnload_SDL_ShowCursor g_symbol_table.SDL_ShowCursor
#define dnload_free g_symbol_table.free
#define dnload_png_set_expand g_symbol_table.png_set_expand
#define dnload_glProgramUniform2fv g_symbol_table.glProgramUniform2fv
#define dnload_glProgramUniform3fv g_symbol_table.glProgramUniform3fv
#define dnload_glProgramUniform4fv g_symbol_table.glProgramUniform4fv
#define dnload_SDL_CreateMutex g_symbol_table.SDL_CreateMutex
#define dnload_glProgramUniformMatrix3fv g_symbol_table.glProgramUniformMatrix3fv
#define dnload_SDL_GetTicks g_symbol_table.SDL_GetTicks
#define dnload_glRects g_symbol_table.glRects
#define dnload_asinf g_symbol_table.asinf
#define dnload_png_create_info_struct g_symbol_table.png_create_info_struct
#define dnload_glActiveTexture g_symbol_table.glActiveTexture
#define dnload_FT_Load_Glyph g_symbol_table.FT_Load_Glyph
#define dnload_SDL_GL_CreateContext g_symbol_table.SDL_GL_CreateContext
#define dnload_png_read_info g_symbol_table.png_read_info
#define dnload_glTexParameterf g_symbol_table.glTexParameterf
#define dnload_glTexParameteri g_symbol_table.glTexParameteri
#define dnload_glProgramUniform1f g_symbol_table.glProgramUniform1f
#define dnload_glProgramUniform1i g_symbol_table.glProgramUniform1i
#define dnload_glReadPixels g_symbol_table.glReadPixels
#define dnload_png_get_valid g_symbol_table.png_get_valid
#define dnload_rand g_symbol_table.rand
#define dnload_glViewport g_symbol_table.glViewport
#define dnload_glEnable g_symbol_table.glEnable
/** \endcond */
/** \brief Symbol table structure.
 *
 * Contains all the symbols required for dynamic linking.
 */
static struct SymbolTableStruct
{
  void (DNLOAD_APIENTRY *glGenerateMipmap)(GLenum);
  int (*SDL_CondSignal)(SDL_cond*);
  png_structp (*png_create_read_struct)(png_const_charp, png_voidp, png_error_ptr, png_error_ptr);
  int (*SDL_CondWait)(SDL_cond*, SDL_mutex*);
  float (*fmodf)(float, float);
  void (DNLOAD_APIENTRY *glFramebufferTexture2D)(GLenum, GLenum, GLenum, GLuint, GLint);
  float (*sinf)(float);
  void (DNLOAD_APIENTRY *glUseProgramStages)(GLuint, GLbitfield, GLuint);
  void (*png_set_read_fn)(png_structrp, png_voidp, png_rw_ptr);
  void (DNLOAD_APIENTRY *glBindProgramPipeline)(GLuint);
  void (*SDL_GL_SwapWindow)(SDL_Window*);
  void (*SDL_PauseAudio)(int);
  void (*SDL_Delay)(Uint32);
  FT_Error (*FT_Set_Pixel_Sizes)(FT_Face, FT_UInt, FT_UInt);
  FT_Error (*FT_New_Face)(FT_Library, const char*, FT_Long, FT_Face*);
  float (*cosf)(float);
  int (*SDL_UnlockMutex)(SDL_mutex*);
  png_uint_32 (*png_get_IHDR)(png_const_structrp, png_const_inforp, png_uint_32*, png_uint_32*, int*, int*, int*, int*, int*);
  int (*SDL_OpenAudio)(SDL_AudioSpec*, SDL_AudioSpec*);
  void (*png_set_tRNS_to_alpha)(png_structrp);
  SDL_Window* (*SDL_CreateWindow)(const char*, int, int, int, int, Uint32);
  void (*SDL_WaitThread)(SDL_Thread*, int*);
  int (*SDL_PollEvent)(SDL_Event*);
  void (*srand)(unsigned int);
  void (*SDL_DestroyMutex)(SDL_mutex*);
  int (*SDL_Init)(Uint32);
  int (*SDL_LockMutex)(SDL_mutex*);
  void (DNLOAD_APIENTRY *glGenProgramPipelines)(GLsizei, GLuint*);
  FT_Error (*FT_Init_FreeType)(FT_Library*);
  void (*SDL_Quit)(void);
  SDL_Thread* (*SDL_CreateThread)(int (*)(void*), const char*, void*);
  FT_Error (*FT_Render_Glyph)(FT_GlyphSlot, FT_Render_Mode);
  SDL_cond* (*SDL_CreateCond)(void);
  float (*powf)(float, float);
  void (DNLOAD_APIENTRY *glBindTexture)(GLenum, GLuint);
  void (DNLOAD_APIENTRY *glGenTextures)(GLsizei, GLuint*);
  void (*SDL_DestroyCond)(SDL_cond*);
  float (*tanhf)(float);
  void (DNLOAD_APIENTRY *glBindFramebuffer)(GLenum, GLuint);
  void (DNLOAD_APIENTRY *glTexImage2D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*);
  void (DNLOAD_APIENTRY *glTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*);
  GLuint (DNLOAD_APIENTRY *glCreateShaderProgramv)(GLenum, GLsizei, const char**);
  void (*png_read_row)(png_structrp, png_bytep, png_bytep);
  FT_UInt (*FT_Get_Char_Index)(FT_Face, FT_ULong);
  void (DNLOAD_APIENTRY *glGenFramebuffers)(GLsizei, GLuint*);
  void* (*realloc)(void*, size_t);
  void (DNLOAD_APIENTRY *glDisable)(GLenum);
  void (DNLOAD_APIENTRY *glBlendFuncSeparate)(GLenum, GLenum, GLenum, GLenum);
  int (*SDL_ShowCursor)(int);
  void (*free)(void*);
  void (*png_set_expand)(png_structrp);
  void (DNLOAD_APIENTRY *glProgramUniform2fv)(GLuint, GLint, GLsizei, const GLfloat*);
  void (DNLOAD_APIENTRY *glProgramUniform3fv)(GLuint, GLint, GLsizei, const GLfloat*);
  void (DNLOAD_APIENTRY *glProgramUniform4fv)(GLuint, GLint, GLsizei, const GLfloat*);
  SDL_mutex* (*SDL_CreateMutex)(void);
  void (DNLOAD_APIENTRY *glProgramUniformMatrix3fv)(GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
  uint32_t (*SDL_GetTicks)(void);
  void (DNLOAD_APIENTRY *glRects)(GLshort, GLshort, GLshort, GLshort);
  float (*asinf)(float);
  png_infop (*png_create_info_struct)(png_const_structrp);
  void (DNLOAD_APIENTRY *glActiveTexture)(GLenum);
  FT_Error (*FT_Load_Glyph)(FT_Face, FT_UInt, FT_Int32);
  SDL_GLContext (*SDL_GL_CreateContext)(SDL_Window*);
  void (*png_read_info)(png_structrp, png_inforp);
  void (DNLOAD_APIENTRY *glTexParameterf)(GLenum, GLenum, GLfloat);
  void (DNLOAD_APIENTRY *glTexParameteri)(GLenum, GLenum, GLint);
  void (DNLOAD_APIENTRY *glProgramUniform1f)(GLuint, GLint, GLfloat);
  void (DNLOAD_APIENTRY *glProgramUniform1i)(GLuint, GLint, GLint);
  void (DNLOAD_APIENTRY *glReadPixels)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid*);
  png_uint_32 (*png_get_valid)(png_const_structrp, png_const_inforp, png_uint_32);
  int (*rand)(void);
  void (DNLOAD_APIENTRY *glViewport)(GLint, GLint, GLsizei, GLsizei);
  void (DNLOAD_APIENTRY *glEnable)(GLenum);
} g_symbol_table =
{
  (void (DNLOAD_APIENTRY *)(GLenum))0x11741122,
  (int (*)(SDL_cond*))0x11f4f60e,
  (png_structp (*)(png_const_charp, png_voidp, png_error_ptr, png_error_ptr))0x15e37b51,
  (int (*)(SDL_cond*, SDL_mutex*))0x167a16bb,
  (float (*)(float, float))0x16a18daa,
  (void (DNLOAD_APIENTRY *)(GLenum, GLenum, GLenum, GLuint, GLint))0x18781f65,
  (float (*)(float))0x1ab23d2e,
  (void (DNLOAD_APIENTRY *)(GLuint, GLbitfield, GLuint))0x212d8ad7,
  (void (*)(png_structrp, png_voidp, png_rw_ptr))0x228bb79e,
  (void (DNLOAD_APIENTRY *)(GLuint))0x2386bc04,
  (void (*)(SDL_Window*))0x295bfb59,
  (void (*)(int))0x29f14a4,
  (void (*)(Uint32))0x2ccbf01f,
  (FT_Error (*)(FT_Face, FT_UInt, FT_UInt))0x2e0eeab,
  (FT_Error (*)(FT_Library, const char*, FT_Long, FT_Face*))0x2f7e33ed,
  (float (*)(float))0x353e8f7f,
  (int (*)(SDL_mutex*))0x3a574477,
  (png_uint_32 (*)(png_const_structrp, png_const_inforp, png_uint_32*, png_uint_32*, int*, int*, int*, int*, int*))0x463a0d2c,
  (int (*)(SDL_AudioSpec*, SDL_AudioSpec*))0x46fd70c8,
  (void (*)(png_structrp))0x4d8c4963,
  (SDL_Window* (*)(const char*, int, int, int, int, Uint32))0x4fbea370,
  (void (*)(SDL_Thread*, int*))0x62469d23,
  (int (*)(SDL_Event*))0x64949d97,
  (void (*)(unsigned int))0x6b699dd8,
  (void (*)(SDL_mutex*))0x6dda9ec9,
  (int (*)(Uint32))0x70d6574,
  (int (*)(SDL_mutex*))0x72b4ef70,
  (void (DNLOAD_APIENTRY *)(GLsizei, GLuint*))0x75e35418,
  (FT_Error (*)(FT_Library*))0x773710a4,
  (void (*)(void))0x7eb657f3,
  (SDL_Thread* (*)(int (*)(void*), const char*, void*))0x83d86faa,
  (FT_Error (*)(FT_GlyphSlot, FT_Render_Mode))0x88a089d4,
  (SDL_cond* (*)(void))0x8ebee9c2,
  (float (*)(float, float))0x921b2a2e,
  (void (DNLOAD_APIENTRY *)(GLenum, GLuint))0x95e43fb9,
  (void (DNLOAD_APIENTRY *)(GLsizei, GLuint*))0x9bdd4fa3,
  (void (*)(SDL_cond*))0x9c453778,
  (float (*)(float))0x9ec2e83f,
  (void (DNLOAD_APIENTRY *)(GLenum, GLuint))0xa0fdff6b,
  (void (DNLOAD_APIENTRY *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*))0xa259532b,
  (void (DNLOAD_APIENTRY *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*))0xa25a536a,
  (GLuint (DNLOAD_APIENTRY *)(GLenum, GLsizei, const char**))0xa4fd03d8,
  (void (*)(png_structrp, png_bytep, png_bytep))0xabeda07,
  (FT_UInt (*)(FT_Face, FT_ULong))0xb1177d43,
  (void (DNLOAD_APIENTRY *)(GLsizei, GLuint*))0xb1503371,
  (void* (*)(void*, size_t))0xb1ae4962,
  (void (DNLOAD_APIENTRY *)(GLenum))0xb5f7c43,
  (void (DNLOAD_APIENTRY *)(GLenum, GLenum, GLenum, GLenum))0xb82574f3,
  (int (*)(int))0xb88bf697,
  (void (*)(void*))0xc23f2ccc,
  (void (*)(png_structrp))0xc5e8aa0d,
  (void (DNLOAD_APIENTRY *)(GLuint, GLint, GLsizei, const GLfloat*))0xc8ebc2cd,
  (void (DNLOAD_APIENTRY *)(GLuint, GLint, GLsizei, const GLfloat*))0xc969d24e,
  (void (DNLOAD_APIENTRY *)(GLuint, GLint, GLsizei, const GLfloat*))0xc9e7e1cf,
  (SDL_mutex* (*)(void))0xcc177eff,
  (void (DNLOAD_APIENTRY *)(GLuint, GLint, GLsizei, GLboolean, const GLfloat*))0xcdfdc2ed,
  (uint32_t (*)(void))0xd1d0b104,
  (void (DNLOAD_APIENTRY *)(GLshort, GLshort, GLshort, GLshort))0xd419e20a,
  (float (*)(float))0xd7423c8f,
  (png_infop (*)(png_const_structrp))0xd7d46f39,
  (void (DNLOAD_APIENTRY *)(GLenum))0xd7d4d450,
  (FT_Error (*)(FT_Face, FT_UInt, FT_Int32))0xdb48d8e4,
  (SDL_GLContext (*)(SDL_Window*))0xdba45bd,
  (void (*)(png_structrp, png_inforp))0xdbb23dc1,
  (void (DNLOAD_APIENTRY *)(GLenum, GLenum, GLfloat))0xdefef0bf,
  (void (DNLOAD_APIENTRY *)(GLenum, GLenum, GLint))0xdefef0c2,
  (void (DNLOAD_APIENTRY *)(GLuint, GLint, GLfloat))0xe1ca37aa,
  (void (DNLOAD_APIENTRY *)(GLuint, GLint, GLint))0xe1ca37ad,
  (void (DNLOAD_APIENTRY *)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid*))0xe325dd28,
  (png_uint_32 (*)(png_const_structrp, png_const_inforp, png_uint_32))0xe4f5c5dd,
  (int (*)(void))0xe83af065,
  (void (DNLOAD_APIENTRY *)(GLint, GLint, GLsizei, GLsizei))0xecca892b,
  (void (DNLOAD_APIENTRY *)(GLenum))0xf1854d68,
};
#endif

#if defined(USE_LD)
/** \cond */
#define dnload()
/** \endcond */
#else
#include <stdint.h>
/** \brief SDBM hash function.
 *
 * \param op String to hash.
 * \return Full hash.
 */
static uint32_t sdbm_hash(const uint8_t *op)
{
  uint32_t ret = 0;
  for(;;)
  {
    uint32_t cc = *op++;
    if(!cc)
    {
      return ret;
    }
    ret = ret * 65599 + cc;
  }
}
#if defined(__FreeBSD__)
#include <sys/link_elf.h>
#elif defined(__linux__)
#include <link.h>
#else
#error "no elf header location known for current platform"
#endif
#if (8 == DNLOAD_POINTER_SIZE)
/** Elf header type. */
typedef Elf64_Ehdr dnload_elf_ehdr_t;
/** Elf program header type. */
typedef Elf64_Phdr dnload_elf_phdr_t;
/** Elf dynamic structure type. */
typedef Elf64_Dyn dnload_elf_dyn_t;
/** Elf symbol table entry type. */
typedef Elf64_Sym dnload_elf_sym_t;
/** Elf dynamic structure tag type. */
typedef Elf64_Sxword dnload_elf_tag_t;
#else
/** Elf header type. */
typedef Elf32_Ehdr dnload_elf_ehdr_t;
/** Elf program header type. */
typedef Elf32_Phdr dnload_elf_phdr_t;
/** Elf dynamic structure type. */
typedef Elf32_Dyn dnload_elf_dyn_t;
/** Elf symbol table entry type. */
typedef Elf32_Sym dnload_elf_sym_t;
/** Elf dynamic structure tag type. */
typedef Elf32_Sword dnload_elf_tag_t;
#endif
/** \brief ELF base address. */
#define ELF_BASE_ADDRESS 0x2000000
/** \brief Get dynamic section element by tag.
 *
 * \param dyn Dynamic section.
 * \param tag Tag to look for.
 * \return Pointer to dynamic element.
 */
static const dnload_elf_dyn_t* elf_get_dynamic_element_by_tag(const void *dyn, dnload_elf_tag_t tag)
{
  const dnload_elf_dyn_t *dynamic = (const dnload_elf_dyn_t*)dyn;
  do {
    ++dynamic; // First entry in PT_DYNAMIC is probably nothing important.
#if defined(__linux__) && defined(DNLOAD_SAFE_SYMTAB_HANDLING)
    if(0 == dynamic->d_tag)
    {
      return NULL;
    }
#endif
  } while(dynamic->d_tag != tag);
  return dynamic;
}
#if defined(DNLOAD_NO_FIXED_R_DEBUG_ADDRESS) || defined(DNLOAD_SAFE_SYMTAB_HANDLING)
/** \brief Get the address associated with given tag in a dynamic section.
 *
 * \param dyn Dynamic section.
 * \param tag Tag to look for.
 * \return Address matching given tag.
 */
static const void* elf_get_dynamic_address_by_tag(const void *dyn, dnload_elf_tag_t tag)
{
  const dnload_elf_dyn_t *dynamic = elf_get_dynamic_element_by_tag(dyn, tag);
#if defined(__linux__) && defined(DNLOAD_SAFE_SYMTAB_HANDLING)
  if(NULL == dynamic)
  {
    return NULL;
  }
#endif
  return (const void*)dynamic->d_un.d_ptr;
}
#endif
#if !defined(DNLOAD_NO_FIXED_R_DEBUG_ADDRESS)
/** Link map address, fixed location in ELF headers. */
extern const struct r_debug *dynamic_r_debug;
#endif
/** \brief Get the program link map.
 *
 * \return Link map struct.
 */
static const struct link_map* elf_get_link_map()
{
#if defined(DNLOAD_NO_FIXED_R_DEBUG_ADDRESS)
  // ELF header is in a fixed location in memory.
  // First program header is located directly afterwards.
  const dnload_elf_ehdr_t *ehdr = (const dnload_elf_ehdr_t*)ELF_BASE_ADDRESS;
  const dnload_elf_phdr_t *phdr = (const dnload_elf_phdr_t*)((size_t)ehdr + (size_t)ehdr->e_phoff);
  do {
    ++phdr; // Dynamic header is probably never first in PHDR list.
  } while(phdr->p_type != PT_DYNAMIC);
  // Find the debug entry in the dynamic header array.
  {
    const struct r_debug *debug = (const struct r_debug*)elf_get_dynamic_address_by_tag((const void*)phdr->p_vaddr, DT_DEBUG);
    return debug->r_map;
  }
#else
  return dynamic_r_debug->r_map;
#endif
}
/** \brief Return pointer from link map address.
 *
 * \param lmap Link map.
 * \param ptr Pointer in this link map.
 */
static const void* elf_transform_dynamic_address(const struct link_map *lmap, const void *ptr)
{
#if defined(__linux__)
  // Addresses may also be absolute.
  if(ptr >= (void*)(size_t)lmap->l_addr)
  {
    return ptr;
  }
#endif
  return (uint8_t*)ptr + (size_t)lmap->l_addr;
}
#if defined(DNLOAD_SAFE_SYMTAB_HANDLING)
/** \brief Get address of one dynamic section corresponding to given library.
 *
 * \param lmap Link map.
 * \param tag Tag to look for.
 * \return Pointer to given section or NULL.
 */
static const void* elf_get_library_dynamic_section(const struct link_map *lmap, dnload_elf_tag_t tag)
{
  return elf_transform_dynamic_address(lmap, elf_get_dynamic_address_by_tag(lmap->l_ld, tag));
}
#endif
/** \brief Find a symbol in any of the link maps.
 *
 * Should a symbol with name matching the given hash not be present, this function will happily continue until
 * we crash. Size-minimal code has no room for error checking.
 *
 * \param hash Hash of the function name string.
 * \return Symbol found.
 */
static void* dnload_find_symbol(uint32_t hash)
{
  const struct link_map* lmap = elf_get_link_map();
#if defined(__linux__) && (8 == DNLOAD_POINTER_SIZE)
  // On 64-bit Linux, the second entry is not usable.
  lmap = lmap->l_next;
#endif
  for(;;)
  {
    // First entry is this object itself, safe to advance first.
    lmap = lmap->l_next;
    {
#if defined(DNLOAD_SAFE_SYMTAB_HANDLING)
      // Find symbol from link map. We need the string table and a corresponding symbol table.
      const char* strtab = (const char*)elf_get_library_dynamic_section(lmap, DT_STRTAB);
      const dnload_elf_sym_t *symtab = (const dnload_elf_sym_t*)elf_get_library_dynamic_section(lmap, DT_SYMTAB);
      const uint32_t* hashtable = (const uint32_t*)elf_get_library_dynamic_section(lmap, DT_HASH);
      unsigned dynsymcount;
      unsigned ii;
#if defined(__linux__)
      if(NULL == hashtable)
      {
        hashtable = (const uint32_t*)elf_get_library_dynamic_section(lmap, DT_GNU_HASH);
        // DT_GNU_HASH symbol counter borrows from FreeBSD rtld-elf implementation.
        dynsymcount = 0;
        {
          unsigned bucket_count = hashtable[0];
          const uint32_t* buckets = hashtable + 4 + ((sizeof(void*) / 4) * hashtable[2]);
          const uint32_t* chain_zero = buckets + bucket_count + hashtable[1];
          for(ii = 0; (ii < bucket_count); ++ii)
          {
            unsigned bkt = buckets[ii];
            if(bkt == 0)
            {
              continue;
            }
            {
              const uint32_t* hashval = chain_zero + bkt;
              do {
                ++dynsymcount;
              } while(0 == (*hashval++ & 1u));
            }
          }
        }
      }
      else
#endif
      {
        dynsymcount = hashtable[1];
      }
      for(ii = 0; (ii < dynsymcount); ++ii)
      {
        const dnload_elf_sym_t *sym = &symtab[ii];
#else
      // Assume DT_SYMTAB dynamic entry immediately follows DT_STRTAB dynamic entry.
      // Assume DT_STRTAB memory block immediately follows DT_SYMTAB dynamic entry.
      const dnload_elf_dyn_t *dynamic = elf_get_dynamic_element_by_tag(lmap->l_ld, DT_STRTAB);
      const char* strtab = (const char*)elf_transform_dynamic_address(lmap, (const void*)(dynamic->d_un.d_ptr));
      const dnload_elf_sym_t *sym = (const dnload_elf_sym_t*)elf_transform_dynamic_address(lmap, (const void*)((dynamic + 1)->d_un.d_ptr));
      for(; ((void*)sym < (void*)strtab); ++sym)
      {
#endif
        const char *name = strtab + sym->st_name;
#if defined(DNLOAD_SAFE_SYMTAB_HANDLING)
        // UND symbols have valid names but no value.
        if(!sym->st_value)
        {
          continue;
        }
#endif
        if(sdbm_hash((const uint8_t*)name) == hash)
        {
          //if(!sym->st_value)
          //{
          //  printf("incorrect symbol in library '%s': '%s'\n", lmap->l_name, name);
          //}
          return (void*)((const uint8_t*)sym->st_value + (size_t)lmap->l_addr);
        }
      }
    }
  }
}
/** \brief Perform init.
 *
 * Import by hash - style.
 */
static void dnload(void)
{
  unsigned ii;
  for(ii = 0; (73 > ii); ++ii)
  {
    void **iter = ((void**)&g_symbol_table) + ii;
    *iter = dnload_find_symbol(*(uint32_t*)iter);
  }
}
#endif

#if defined(__clang__)
/** Visibility declaration for symbols that require it (clang). */
#define DNLOAD_VISIBILITY __attribute__((visibility("default")))
#else
/** Visibility declaration for symbols that require it (gcc). */
#define DNLOAD_VISIBILITY __attribute__((externally_visible,visibility("default")))
#endif

#if !defined(USE_LD)
#if defined(__cplusplus)
extern "C" {
#endif
/** Program entry point. */
void _start() DNLOAD_VISIBILITY;
#if defined(__cplusplus)
}
#endif
#endif
#endif

